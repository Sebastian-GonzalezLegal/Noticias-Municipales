(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("@usig-gcba/usig-core"), require("isomorphic-fetch"));
	else if(typeof define === 'function' && define.amd)
		define("Callejero", ["@usig-gcba/usig-core", "isomorphic-fetch"], factory);
	else if(typeof exports === 'object')
		exports["Callejero"] = factory(require("@usig-gcba/usig-core"), require("isomorphic-fetch"));
	else
		root["Callejero"] = factory(root["@usig-gcba/usig-core"], root["isomorphic-fetch"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_4__, __WEBPACK_EXTERNAL_MODULE_5__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 6);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});

__webpack_require__(5);

var _Calle = __webpack_require__(1);

var _Calle2 = _interopRequireDefault(_Calle);

var _ErrorSinDatos = __webpack_require__(3);

var _ErrorSinDatos2 = _interopRequireDefault(_ErrorSinDatos);

var _ErrorSinAlturas = __webpack_require__(2);

var _usigCore = __webpack_require__(4);

var _usigCore2 = _interopRequireDefault(_usigCore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Definicion del namespace
var usig = void 0;
if (typeof usig === "undefined") usig = {};

if (typeof usig.data === "undefined") usig.data = {};

if (typeof usig.defaults === "undefined") usig.defaults = {};

usig.defaults.Callejero = {
    server: 'https://servicios.usig.buenosaires.gob.ar/callejero',
    // server: '//liebre/wk/Callejero/src/www/server.php',
    lazyDataLoad: false,
    loadFullDatabase: true,
    callesEnMinusculas: true,
    encoding: 'utf-8',
    expirationTime: 10080 // una semana
};

/**
 * @class Callejero
 * Esta clase es la interfaz con el callejero de USIG. Es un singleton y todos los metodos estan accesibles
 * a traves de usig.Callejero. El componente debe inicializarse previamente llamando al metodo init.
 * @namespace usig
 * @cfg {String} server URL del servidor de datos de calles. Tiene un valor por defecto.
 * @cfg {Boolean} lazyDataLoad Determina si los datos del callejero deben cargarse al inicializar 
 * 		el componente o solo cuando se lo quiera usar por primera vez.
 * @cfg {Function} onReady Callback que es llamada cuando ya se cargaron los datos del callejero.
 * @singleton
*/
var opts = {},
    myself = undefined,
    initialized = false,
    listeners = {
    'ready': []
},
    loadingData = false;

/**
 * Busca las palabras de la direccion ingresada, en las keyword de un registro del callejero
 * @param {Array} wordsRE Array de expresiones regulares de las palabras a buscar
 * @param {Array} calle Array con los datos de una calle del callejero
 * @return {boolean} true si todas las palabras de wordsRE coinciden con el comienzo de alguna palabra de las keywords de calle.
 */
function matchea(wordsRE, calle) {
    var match = true;
    for (var w = 0; w < wordsRE.length; w++) {
        var r = wordsRE[w];
        r.lastIndex = 0;
        if (!r.test(calle[2])) {
            match = false;
            break;
        }
    }
    return match;
}

function mergeDatosCruces(data) {
    loadingData = false;
    if (data.length != usig.data.Callejero.length) {
        alert('Se produjo un error al cargar la información de cruces de calles.');
        return;
    }
    for (var i = 0; i < usig.data.Callejero.length; i++) {
        usig.data.Callejero[i].push(data[i]);
    }
}

function guardarLocalStorage(data) {
    var expirationMS = opts.expirationTime * 60 * 1000;
    var record = { calles: JSON.stringify(data), expiration: new Date().getTime() + expirationMS };
    try {
        if (localStorage) localStorage["callejero"] = JSON.stringify(record);
    } catch (e) {
        console.error(e);
    }
}

function cargarCallejero(data) {
    initialized = true;
    usig.data.Callejero = data;
    loadingData = false;
    eventHandler('ready');
    return callejero;
}

function cargarCruces() {
    loadingData = true;

    fetch(opts.server + "?full=1&cruces=1&encoding=" + opts.encoding).then(function (response) {
        return response.json();
    }, function (error) {
        return console.log('Error!');
    }).then(function (json) {
        return mergeDatosCruces(json);
    });
}

function _cargarCallejero() {
    loadingData = true;

    var data = opts.loadFullDatabase ? '?full=1&encoding=' + opts.encoding + '&minusculas=' + (opts.callesEnMinusculas ? 1 : 0) : '?encoding=' + opts.encoding + '&minusculas=' + (opts.callesEnMinusculas ? 1 : 0);
    return fetch(opts.server + data + "&date=" + Date.now()).then(function (response) {
        return response.json();
    }).catch(function (error) {
        throw error;
    }).then(function (json) {
        guardarLocalStorage(json);
        return cargarCallejero(json);
    }).catch(function (error) {
        throw error;
    });
}
// Comollego puede enviar un callejero cargado en memoria
function _cargarCalles(callejero) {
    if (!loadingData) {
        if (!supports_html5_storage()) {
            return callejero ? new Promise(function (resolve) {
                return resolve(cargarCallejero(callejero));
            }) : _cargarCallejero();
        } else {
            // soporta HTML5

            var callejeroLocalStorage;
            try {
                if (localStorage["callejero"]) callejeroLocalStorage = JSON.parse(localStorage["callejero"]);

                if (callejeroLocalStorage && callejeroLocalStorage.calles && callejeroLocalStorage.calles.length > 500) {
                    // Ya hay una copia del callejero en localStorage
                    // Si la version guardada es vieja, se vuelve a buscar, sino se usa el guardado
                    // Si falla la busqueda, devuelvo el que tenia guardado
                    return new Date().getTime() < callejeroLocalStorage.expiration ? new Promise(function (resolve) {
                        return resolve(cargarCallejero(JSON.parse(callejeroLocalStorage.calles)));
                    }) : _cargarCallejero().catch(function (err) {
                        return cargarCallejero(JSON.parse(callejeroLocalStorage.calles));
                    });
                } else {
                    // Si no hay datos en localStorage, uso el callejero que me pasan
                    if (callejero) {
                        guardarLocalStorage(callejero);
                        return new Promise(function (resolve) {
                            return resolve(cargarCallejero(callejero));
                        });
                    }
                    // Si no me pasaon ninguno, lo voy a buscar
                    return _cargarCallejero().catch(function (err) {
                        throw err;
                    });
                }
            } catch (e) {
                // Por si falla algun paso, se va a buscar el callejero o se usa el que me pasan
                console.error(e);
                return callejero ? new Promise(function (resolve) {
                    return resolve(cargarCallejero(callejero));
                }) : _cargarCallejero();
            }
        }
    }
}

function supports_html5_storage() {
    try {
        return 'localStorage' in window && window['localStorage'] !== null;
    } catch (e) {
        return false;
    }
}

function eventHandler(ev) {
    for (var i = 0; i < listeners[ev].length; i++) {
        listeners[ev][i]();
    }
}

function setHandler(ev, handler) {
    var found = false;
    for (var i = 0; i < listeners[ev].length; i++) {
        found = found || listeners[ev][i] == handler;
    }
    if (!found) {
        listeners[ev].push(handler);
    }
}

var callejero = {
    /**
     * Inicializa el componente previo a su primer uso.
     * @param {Object} options (optional) Objeto conteniendo overrides para las opciones por defecto.
     * @return {Object} Devuelve una referencia al componente.
     */
    init: function init(options) {
        opts = Object.assign({}, usig.defaults.Callejero, options);

        if (typeof opts.onReady === "function") {
            setHandler('ready', opts.onReady);
        }
        if (!usig.data.Callejero && !opts.lazyDataLoad || usig.data.Callejero && (usig.data.Callejero.calles || usig.data.Callejero.calles && usig.data.Callejero.calles.length < 500)) {
            return _cargarCalles(opts.callejero).catch(function (err) {
                // Si falla la busqueda y tengo un callejero en memoria, devuelvo ese.
                if (opts.callejero) return cargarCallejero(opts.callejero);
                throw err;
            });
        } else if (usig.data.Callejero) {
            eventHandler('ready');
            listeners['ready'] = [];
        }
        return new Promise(function (resolve) {
            return resolve(callejero);
        });
    },

    /**
     * Pide los datos de las calles.
     * @param {Object} options (optional) Objeto indicando que hacer en el caso de que ya existan datos para las calles.
     * @return {Promise} promise conteniendo el objeto callejero actual o con los datos actualizados.
     */
    cargarCalles: function cargarCalles(options) {
        if (options && callejero.listo()) return options.override ? _cargarCalles() : new Promise(function (resolve) {
            return resolve(callejero);
        });
        return _cargarCalles();
    },
    /**
     * Busca calle por codigo y devuelve una lista de objetos calle
     * @param {int} codigo Codigo de calle a buscar
     * @return {Array of Calle} Calles encontradas
     * @throws {ErrorSinDatos} excepcion si no hay datos cargados.
     */
    buscarPorCodigo: function buscarPorCodigo(codigo) {
        if (!callejero.listo()) throw new _ErrorSinDatos2.default();
        var calles = [];
        if (/^[0-9]+$/.test(codigo)) {
            var index = _usigCore2.default.binarySearch(usig.data.Callejero, codigo, function (a, b) {
                return a[0] - b;
            });
            if (index > -1) {
                var match = usig.data.Callejero[index];
                calles.push(_Calle2.default.construirCalle(match[0], match[1]));
                var i = index + 1;
                while (i < usig.data.Callejero.length && usig.data.Callejero[i][0] === codigo) {
                    match = usig.data.Callejero[i];
                    calles.push(_Calle2.default.construirCalle(match[0], match[1]));
                    i++;
                }
                i = index - 1;
                while (i >= 0 && usig.data.Callejero[i][0] === codigo) {
                    match = usig.data.Callejero[i];
                    calles.unshift(_Calle2.default.construirCalle(match[0], match[1]));
                    i--;
                }
            }
        }
        return calles;
    },
    /**
     * Devuelve las alturas de una calle a partir de su codigo
     * @param {int} codigo Codigo de calle a buscar
     * @return {Array of int} Alturas encontradas
     * @throws {ErrorSinDatos} excepcion si no hay datos cargados.
     */
    getAlturas: function getAlturas(codigo, nombre) {
        if (!callejero.listo()) throw new _ErrorSinDatos2.default();
        var alturas = [];
        if (/^[0-9]+$/.test(codigo)) {
            var index = _usigCore2.default.binarySearch(usig.data.Callejero, codigo, function (a, b) {
                return a[0] - b;
            });
            if (index > -1) {
                var match = usig.data.Callejero[index];
                if (match[1] === nombre) match[3].forEach(function (alt) {
                    return alturas.push(alt);
                });
                var i = index + 1;
                while (i < usig.data.Callejero.length && usig.data.Callejero[i][0] === codigo) {
                    if (usig.data.Callejero[i][1] === nombre) {
                        match = usig.data.Callejero[i];
                        match[3].forEach(function (alt) {
                            return alturas.push(alt);
                        });
                    }
                    i++;
                }
                i = index - 1;
                while (i >= 0 && usig.data.Callejero[i][0] === codigo) {
                    if (usig.data.Callejero[i][1] === nombre) {
                        match = usig.data.Callejero[i];
                        match[3].forEach(function (alt) {
                            return alturas.push(alt);
                        });
                    }
                    i--;
                }
            }
        }
        return alturas;
    },
    /**
     * Devuelve los cruces de una calle a partir de su codigo y su nombre
     * @param {int} codigo Codigo de calle a buscar
     * @param {string} nombre Codigo de calle a buscar
     * @return {Array of int} Alturas encontradas
     * @throws {ErrorSinDatos} excepcion si no hay datos cargados.
     */
    getCruces: function getCruces(codigo, nombre) {
        if (!callejero.listo()) throw new _ErrorSinDatos2.default();
        var cruces = [];
        if (/^[0-9]+$/.test(codigo)) {
            var index = _usigCore2.default.binarySearch(usig.data.Callejero, codigo, function (a, b) {
                return a[0] - b;
            });
            if (index > -1) {
                var match = usig.data.Callejero[index];
                if (match[1] === nombre) match[4].forEach(function (alt) {
                    return cruces.push(alt);
                });
                var i = index + 1;
                while (i < usig.data.Callejero.length && usig.data.Callejero[i][0] === codigo) {
                    if (usig.data.Callejero[i][1] === nombre) {
                        match = usig.data.Callejero[i];
                        match[4].forEach(function (alt) {
                            return cruces.push(alt);
                        });
                    }
                    i++;
                }
                i = index - 1;
                while (i >= 0 && usig.data.Callejero[i][0] === codigo) {
                    if (usig.data.Callejero[i][1] === nombre) {
                        match = usig.data.Callejero[i];
                        match[4].forEach(function (alt) {
                            return cruces.push(alt);
                        });
                    }
                    i--;
                }
            }
        }
        return cruces;
    },
    /**
     * Verifica si la calle (instancia de la clase usig.Calle) recibida como parametro
     * se cruza con esta
     * @param {usig.Calle} calle1 Calle a verificar si se intersecta con esta
     * @param {usig.Calle} calle2 Calle a verificar si se intersecta con esta
     * @return {Boolean} True en caso de que exista el cruce correspondiente
     */
    seCruzaCon: function seCruzaCon(calle1, calle2) {
        var cruces1 = callejero.getCruces(calle1.codigo, calle1.nombre);
        if (cruces1) {
            return cruces1.indexOf(calle2.codigo) >= 0;
        }
    },
    /**
     * Busca calles cuyo nombre se corresponda con str y devuelve un array con todas las instancias
     * de usig.Calle halladas
     * @param {String} str String a matchear
     * @param {Integer} limit Maximo numero de respuestas a devolver
     * @return {Array} Array de instancias de usig.Calle que matchearon str
     */
    matcheaCalle: function matcheaCalle(str, limit) {
        if (!callejero.listo()) throw new _ErrorSinDatos2.default();
        var opts = [];
        var optsLowPrior = [];
        var input = _usigCore2.default.translate(str.replace(/"/g, ""), 'áéíóúüÁÉÍÓÚÜàèìòùÀÈÌÒÙ', 'aeiouuAEIOUUaeiouAEIOU').toUpperCase().trim();
        var words = input.split(' ');
        var wordsRE = words.map(function (w) {
            return new RegExp("^" + w + "| " + w, "gi");
        });
        var snoRE = new RegExp("SNO|SIN NOMBRE OFICIAL|NO OFICIAL|PASAJE|PJE", 'i');
        if (callejero.listo()) {
            for (var c = 0; c < usig.data.Callejero.length; c++) {
                if (matchea(wordsRE, usig.data.Callejero[c])) {
                    /** almaceno las calles que no tienen nombre oficial o altura en una lista de baja prioridad **/
                    if (!snoRE.test(usig.data.Callejero[c][1]) && usig.data.Callejero[c][3].length !== 0) {
                        opts.push(_Calle2.default.construirCalle(usig.data.Callejero[c][0], usig.data.Callejero[c][1]));
                    } else {
                        optsLowPrior.push(_Calle2.default.construirCalle(usig.data.Callejero[c][0], usig.data.Callejero[c][1]));
                    }
                    if (!isNaN(parseInt(limit)) && opts.length >= parseInt(limit)) break;
                }
            }
            /** junto las listas de resultado de alta y baja prioridad y devuelvo hasta la cantidad limit **/
            opts = opts.concat(optsLowPrior);
            if (!isNaN(parseInt(limit)) && opts.length >= parseInt(limit)) {
                opts = opts.splice(0, limit);
            }
            if (usig.data.Callejero[0].length < 5 && !loadingData) {
                cargarCruces();
            }
        } else {
            _cargarCalles();
            throw new _ErrorSinDatos2.default();
        }
        return opts;
    },

    /**
     * Determina si una calle tiene tramos como Av.
     * @param {int} codigo numero de codigo de la calle
     * @return {Boolean} Retorna True en caso de que la calle tenga tramos como Av.
     */
    tieneTramosComoAv: function tieneTramosComoAv(codigo) {
        /* ATTENTI RAGAZZI
         * Esto funciona estrictamente porque la base de calles viene ordenada por codigo de calles y
         * la unica posibilidad de que una calle tenga tramos como av y calle simultaneamente es que
         * haya un par de registros consecutivos con el mismo codigo (uno para c/caso)
         */
        if (!callejero.listo()) throw new _ErrorSinDatos2.default();
        var index = _usigCore2.default.binarySearch(usig.data.Callejero, codigo, function (a, b) {
            return a[0] - b;
        });
        return index > 0 && codigo !== 0 && (usig.data.Callejero[index - 1][0] === codigo || usig.data.Callejero[index + 1][0] === codigo);
    },

    /**
     * Permite consultar el nombre oficial de una calle dado su codigo y una altura dada
     * @param {int} codigo Codigo oficial de la calle
     * @param {int} altura Altura de la calle
     * @return {String} Retorna el nombre de la calle asociada al codigo indicado en la altura
     * dada o una cadena vacia en caso de error de codigo o altura.
     */
    getNombreCalle: function getNombreCalle(codigo, altura) {
        var calles = callejero.buscarPorCodigo(codigo);
        for (var i = 0; i < calles.length; i++) {
            if (callejero.alturaValida(calles[i], altura)) {
                return calles[i].nombre;
            }
        }
        return "";
    },

    /**
     * Indica si ya se cargaron los datos del callejero.
     * @return {Boolean} Retorna True en caso de que ya se hayan cargado los datos del callejero.
     */
    listo: function listo() {
        return usig.data.Callejero && usig.data.Callejero instanceof Array && usig.data.Callejero.length !== 0;
    },

    /**
     * Indica si el componente ya ha sido inicializado.
     * @return {Boolean} Retorna True si ya se ha llamado al metodo init.
     */
    inicializado: function inicializado() {
        return initialized;
    },
    /**
     * Verifica si la altura es valida para esta calle.
     * @param {Calle} calle a validar
     * @param {int} alt Altura a validar
     * @return {Boolean} True si la altura es valida para esta calle
     */
    alturaValida: function alturaValida(calle, alt) {
        calle.alturas = callejero.getAlturas(calle.codigo, calle.nombre);
        if (calle.alturas instanceof Array) {
            if (calle.alturas.length === 0) {
                throw new _ErrorSinAlturas.ErrorCalleSinAlturas(calle.nombre);
                return false;
            }
            var valid = false;
            for (var a in calle.alturas) {
                valid = valid || parseInt(calle.alturas[a][0]) <= parseInt(alt) && parseInt(calle.alturas[a][1]) >= parseInt(alt);
            }
            return valid;
        }
    },

    /**
     * Devuelve un string con el nombre de la calle
     * @return {String} Nombre de la calle
     */
    calleToString: function calleToString(calle) {
        return calle.nombre;
    }
};

exports.default = callejero;
module.exports = exports['default'];

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @class Calle
 * @namespace usig
 * @constructor
 * @param {Integer} cod Codigo de calle
 * @param {String} nom Nombre oficial de la calle
 * @param {Array} alturas (optional) Array conteniendo los rangos de altura validos para esta calle
 * @param {Array} cruces (optional) Array conteniendo los id de las calles que se cruzan con esta
 */

var TIPO = "CALLE";
exports.default = {
  construirCalle: function construirCalle(cod, nom) {
    return {
      codigo: cod,
      nombre: nom,
      tipo: TIPO,
      toString: nom
    };
  }
};
module.exports = exports["default"];

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ErrorCalleSinAlturas = ErrorCalleSinAlturas;
/**
 * Created by federuiz on 7/14/17.
 */
/**
 * @class ErrorCalleSinAlturas
 * @namespace usig
 * @constructor
 * @param {String} str Nombre oficial de la calle
 */
function ErrorCalleSinAlturas(str) {
  this.id = 3;
  this.message = 'La calle {calle} no posee alturas oficiales. Utilice intersecciones para hallar direcciones v&aacute;lidas sobre esta calle o escriba S/N en lugar de la altura.';

  /**
   * Devuelve un mensaje de error con el nombre de la calle
   * @return {String} Mensaje de error
   */
  this.toString = function () {
    return this.message.replace('{calle}', str);
  };

  /**
   * Devuelve el nombre de la calle
   * @return {String} Nombre de la calle
   */
  this.getNombreCalle = function () {
    return str;
  };

  /**
   * Devuelve un mensaje de error más descriptivo y amigable
   * @return {String} Mensaje de error
   */
  this.getErrorMessage = function () {
    return usig.ErrorCalleSinAlturas.defaults.texts.message.replace('{calle}', str);
  };
}

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * @class ErrorEnCargaDelCallejero
 * @namespace usig
 * @constructor
 */
function ErrorEnCargaDelCallejero() {

  this.message = "El callejero no se encuentra cargado aún o se produjo un error al intentar cargarlo";
  /**
   * Devuelve un mensaje de error
   * @return {String} Mensaje de error
   */
  this.toString = function () {
    return "Callejero no disponible.";
  };

  /**
   * Devuelve un mensaje de error más descriptivo y amigable
   * @return {String} Mensaje de error
   */
  this.getErrorMessage = function () {
    return this.message;
  };
}
exports.default = ErrorEnCargaDelCallejero;
module.exports = exports["default"];

/***/ }),
/* 4 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_4__;

/***/ }),
/* 5 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_5__;

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(0);


/***/ })
/******/ ]);
});
//# sourceMappingURL=Callejero.js.map