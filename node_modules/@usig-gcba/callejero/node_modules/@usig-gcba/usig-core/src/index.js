/**
 * @class Object
 * Este archivo contiene extensiones al lenguaje Javascript estandar
 * rippeadas de ExtJS 2.2.1 y adaptadas a jQuery (usa jQuery.extend en lugar de Ext.apply)
 *
 * Todas las extensiones estan tal cual salvo el metodo remove agregado a los Arrays que fue
 * renombrado por removeObject para evitar conflictos con el metodo remove de jQuery
 */

const core = {
  /**
   * Escapes the passed string for ' and \
   * @param {String} string The string to escape
   * @return {String} The escaped string
   * @static
   */
    escape : function(string) {
        return string.replace(/('|\\)/g, "\\$1");
    },

    /**
     * Pads the left side of a string with a specified character.  This is especially useful
     * for normalizing number and date strings.  Example usage:
     * <pre><code>
     let s = String.leftPad('123', 5, '0');
     // s now contains the string: '00123'
     </code></pre>
     * @param {String} string The original string
     * @param {Number} size The total length of the output string
     * @param {String} char (optional) The character with which to pad the original string (defaults to empty string " ")
     * @return {String} The padded string
     * @static
     */
    leftPad : function (val, size, ch) {
        let result = new String(val);
        if(!ch) {
            ch = " ";
        }
        while (result.length < size) {
            result = ch + result;
        }
        return result.toString();
    },

    /**
     * Allows you to define a tokenized string and pass an arbitrary number of arguments to replace the tokens.  Each
     * token must be unique, and must increment in the format {0}, {1}, etc.  Example usage:
     * <pre><code>
     let cls = 'my-class', text = 'Some text';
     let s = String.format('&lt;div class="{0}">{1}&lt;/div>', cls, text);
     // s now contains the string: '&lt;div class="my-class">Some text&lt;/div>'
     </code></pre>
     * @param {String} string The tokenized string to be formatted
     * @param {String} value1 The value to replace token {0}
     * @param {String} value2 Etc...
     * @return {String} The formatted string
     * @static
     */
    format : function(format){
        let args = Array.prototype.slice.call(arguments, 1);
        return format.replace(/\{(\d+)\}/g, function(m, i){
            return args[i];
        });
    },
    /**
     * Utility function that allows you to easily switch a string between two alternating values.  The passed value
     * is compared to the current string, and if they are equal, the other value that was passed in is returned.  If
     * they are already different, the first value passed in is returned.  Note that this method returns the new value
     * but does not change the current string.
     * <pre><code>
     // alternate sort directions
     sort = sort.toggle('ASC', 'DESC');

     // instead of conditional logic:
     sort = (sort == 'ASC' ? 'DESC' : 'ASC');
     </code></pre>
     * @param {String} value The value to compare to the current string
     * @param {String} other The new value to use if the string already equals the first value passed in
     * @return {String} The new value
     */
    toggle: function(string, value, other){
        return string === value ? other : value;
    },

    /**
     * Trims whitespace from either end of a string, leaving spaces within the string intact.  Example:
     * <pre><code>
     let s = '  foo bar  ';
     alert('-' + s + '-');         //alerts "- foo bar -"
     alert('-' + s.trim() + '-');  //alerts "-foo bar-"
     </code></pre>
     * @return {String} The trimmed string
     */
    trim: function(string){
        let re = /^\s+|\s+$/g;
        return string.replace(re, "");
    },

    /**
     * Replaces each element from the 'from' array with the corresponding one in the 'to' array.
     * @return {String} The translated string
     */
    translate: function(string, from, to) {
        if (!(from.length && to.length) || from.length != to.length)
            return string;
        let str = string;
        for (let i=0;i<from.length;i++) {
            if (typeof(from) === "string") {
                str = str.replace(new RegExp(from.charAt(i), "g"), to.charAt(i));
            } else {
                str = str.replace(new RegExp(from[i], "g"), to[i]);
            }
        }
        return str;
    },

    /**
     * Tests the string to verify that each character be a digit (0-9).
     * @return {Boolean} True if all characters are digits
     */
    isDigit: function(string){ return /^\d+$/.test(string); },

    /**
     * Utility function that allows you to easily remove certain words from a string.
     * @param {Array} words The words you wish to remove
     * @return {String} The new string
     */
    removeWords: function(string, words) {
        let myWords = string.split(' ');
        let res = new Array();
        for (let i=0; i<myWords.length; i++) {
            res.push(myWords[i]);
            for(let j=0; j<words.length; j++) {
                if (res[i] == words[j]) {
                    res.pop();
                    break;
                }
            }
        }
        return res.join(' ');
    },
    /**
     * Performs a binary search in an ordered array using a comparator defined exactly like the one
     * required by sort.
     * @param {Object} find The object to find
     * @param {Function} comparator The comparison function to use
     * @return {Integer} the index of the found element or -1 if none is found
     */
    binarySearch : function binarySearch(array, find, comparator) {
        let low = 0, high = array.length - 1, i, comparison;
        while (low <= high) {
            i = parseInt((low + high) / 2, 10);
            comparison = comparator(array[i], find);
            if (comparison < 0) { low = i + 1; continue; }
            if (comparison > 0) { high = i - 1; continue; }
            return i;
        }
        return -1;
    },
    /**
     * Implements an injection function like the on present in functional languages or Smalltalk.
     * @param {Object} acc The accumulator
     * @param {Function} it The function to use during iteration
     * @return {Object} the resulting accumulator
     */
    inject : function (array, acc, it) {
        for (let i=0; i< array.length; i++)
            acc = it(acc, array[i], i);
        return acc;
    },
    /**
     * Syntax
     * Array Array.intersect([ Array a0 ... an ])
     * Computes the intersection between the calling array and any number of arrays passed as arguments. Duplicate values are removed from the result
     *
     * Parameters
     * Array a0 ... an (Optional)
     * The arrays to intersect with.
     *
     * Return value
     * A new array holding the intersection of elements
     *
     * Examples
     * To find the intersection of the arrays (0,2,4,1,8,2), (1,3,5,2,9) and (100,2,9,1)
     <pre><code>
     // Define array 1
     let a1 = [0,2,4,1,8];
     // Define array 2
     let a2 = [1,3,5,2,9];
     // Define array 3
     let a3 = [100,2,9,1];
     // Output is Array(2,1)
     a1.intersect(a2,a3);
     </pre></code>
     */
    intersect: function(array) {
        if (arguments.length === 1)
            return [];
        let a1 = array;
        let a = a2 = null;
        let n = 1;
        while(n < arguments.length) {
            a = [];
            a2 = arguments[n];
            let l = a1.length;
            let l2 = a2.length;
            for(let i=0; i<l; i++) {
                for(let j=0; j<l2; j++) {
                    if (a1[i] === a2[j])
                        a.push(a1[i]);
                }
            }
            a1 = a;
            n++;
        }
        return a.unique();
    },

    /**
     * Method Array.unique
     * Remove any duplicates from an array
     *
     * Syntax
     * Array Array.unique()
     *
     * This function will return a new array with duplicates of the original array removed
     * Return value
     * A new array with no duplicates
     * Examples
     <pre><code>
     To remove the duplicates in the array (0,2,4,2,6,4,8,6,10);
     // Define array
     let a = new Array(0,2,4,2,6,4,8,6,10);
     // Output is (0,2,4,8,6,10)
     a.unique();
     <pre><code>
     */
    unique: function(array) {
        let a = [];
        let l = array.length;
        for(let i=0; i<l; i++) {
            for(let j=i+1; j<l; j++) {
                // If this[i] is found later in the array
                if (array[i] === array[j])
                    j = ++i;
            }
            a.push(array[i]);
        }
        return a;
    }
};
export default core;

