import Callejero from '@usig-gcba/callejero';
import * as exceptions from 'Exceptions.js'
import StringDireccion from 'StringDireccion.js'
import {CALLE, CALLE_ALTURA, CALLE_Y_CALLE, INVALIDO} from 'constants.js'
import {EXCEPCION_CALLE_SIN_ALTURAS} from 'constants.js'
import Direccion from 'Direccion.js'
import Core from '@usig-gcba/usig-core'
import NormalizadorAMBA from 'NormalizadorDireccionesAMBA'

let defaults = {
    lazyDataLoad: false,
    loadFullDatabase: true,
    aceptarCallesSinAlturas: false,
    callesEnMinusculas: false,
    maxPalabras: 7
};

/**
 * @class NormalizadorDirecciones
 * Esta clase implementa integramente en Javascript un normalizador de direcciones que utiliza
 * el callejero de USIG para transformar un string en una direccion normalizada.
 * Ejemplo de uso:
 * <pre><code>
 * ...
 * &lt;script src="http:&#47;&#47;ajax.googleapis.com/ajax/libs/jquery/1.3.2/jquery.min.js" type="text/javascript"&gt;&lt;/script&gt;
 * &lt;script src="http:&#47;&#47;servicios.usig.buenosaires.gob.ar/nd-js/1.4/normalizadorDirecciones.min.js" type="text/javascript"&gt;&lt;/script&gt;
 * ...
 * let n = usig.NormalizadorDirecciones.init();
 * try {
 *      let opts = n.normalizar(input.value, 10);
 * } catch (error) {
 *      // ...
 * }
 *
 * // Show opts
 *
 * </code></pre>
 * @namespace usig
 * @cfg {Boolean} lazyDataLoad Indica al normalizador si debe cargar los datos del callejero inmediatamente al
 * inicializarse la clase o esperar a la primera llamada al metodo normalizar. Por defecto es <code>False</code>.
 * @cfg {Boolean} aceptarCallesSinAlturas Indica al normalizador si debe permitir como altura S/N para las calles
 * sin numero. Por defecto es <code>False</code>. Ej: de los italianos S/N
 * @cfg {Boolean} callesEnMinusculas Indica si se desea que los nombres de las calles normalizados sean en minúsculas (Por defecto: false)
 * @cfg {Function} onReady Callback que es llamada cuando ya se cargaron los datos del callejero y pueden hacerse
 * 	normalizaciones.
 * @singleton
*/
let opts = {},
    initialized = false,
    startedInit = false,
    callejeroPromise = null,
    listeners = {
        'ready': []
    },
    c = null,
re = {
    cruceCalles: /\s+y\s+/gi,
    calleAltura: [],
    calle: []
};

function normalizarCalleAltura(strDir, maxOptions, autoDesambiguarCalleAltura) {
    let calles = c.matcheaCalle(strDir.strCalles);
    let options;
    try {
        options = validarAlturas(strDir, calles, maxOptions);
    } catch (error) {
        throw(error);
    }
    if (options.length === 0 && calles.length > 0) {
        strDir.quitarAvsCalle();
        calles = c.matcheaCalle(strDir.strCalles);
        try {
          options = validarAlturas(strDir, calles, maxOptions);
        } catch (error) {
            throw(error);
        }
        options = filtrarCallesQueNoSonAv(options);
        if (options.length === 0) {
            throw(new exceptions.ErrorCalleInexistenteAEsaAltura(strDir.strCalles, calles, strDir.strAltura));
        }
    } else if (options.length === 0 && calles.length === 0) {
        strDir.quitarPasajes();
        calles = c.matcheaCalle(strDir.strCalles);
        try {
            options = validarAlturas(strDir, calles, maxOptions);
        } catch (error) {
            throw(error);
        }
    }

    if (autoDesambiguarCalleAltura && options.length > 1) {
        options.forEach((opt, i) => {
            if (esPermutacion(strDir.strCalles, opt.calle.nombre)) {
                options = [opt];
            }
			/*else {
			 usig.debug(strDir.strCalles + ' NO es permutacion de ' + opt.calle.nombre);
			 }*/
        });
    }

    return options;
}

function esPermutacion(str1, str2) {
    function prepararStr(str) {
        str = Core.translate(str.replace(/"/g, ""),'áéíóúüÁÉÍÓÚÜàèìòùÀÈÌÒÙ', 'aeiouuAEIOUUaeiouAEIOU').toUpperCase().trim();
        str = str.split(" ");
        return str;
    }

    str1 = prepararStr(str1);
    str2 = prepararStr(str2);

    if (str1.length === str2.length){
        let intersect = Core.intersect(str1, str2);

        if (str1.length === intersect.length) {
            return true
        }
    }

    return false;
}


/*
 *
 def esPermutacion(strIn1, strIn2):
 def prepararString(strIn):
 if isinstance(strIn, str):
 strIn = unicode(strIn)
 strIn = ''.join((c for c in unicodedata.normalize('NFD', strIn) if unicodedata.category(c) != 'Mn'))
 strIn = re.sub('[^a-zA-Z0-9 ]', '', strIn)
 strIn = strIn.upper().split(' ')
 return strIn

 retval = False
 strIn1 = prepararString(strIn1)
 strIn2 = prepararString(strIn2)

 if (len(strIn1) == len(strIn2)):
 intersec = set(strIn1) & set(strIn2)
 if (len(strIn1) == len(intersec)):
 retval = True

 return retval
 */
function validarAlturas(strDir, calles, maxOptions) {
    let retval = [];
    let hayCalleSN = 0;
    if(calles.length !== 0){
        for (let i=0; i<calles.length; i++) {
            try {
                if (c.alturaValida(calles[i], strDir.strAltura)) {
                    retval.push(Direccion.construirDireccion(calles[i], strDir.strAltura));
                }
            } catch (error) {
                if (error.id === EXCEPCION_CALLE_SIN_ALTURAS && opts.aceptarCallesSinAlturas && strDir.esAlturaSN.test(strDir.strAltura)){
                    retval.push(Direccion.construirDireccion(calles[i], 0));
                }
                hayCalleSN++;
            }
            if (!isNaN(parseInt(maxOptions)) && retval.length >= parseInt(maxOptions))
                break;
        }
        if (calles.length === hayCalleSN && retval.length === 0){
            throw(new exceptions.ErrorCalleSinAlturas(calles[0].nombre));
        }
    }
    return retval;
}

function filtrarCallesQueNoSonAv(dirs, getFunc) {
    let opts = [];
    for (let i=0;i<dirs.length;i++) {
        if (c.tieneTramosComoAv(dirs[i].calle.codigo)) {
            opts.push(dirs[i]);
        }
    }
    return opts;
}

function normalizarCalleYCalle(strDir, maxOptions) {
    let calles1 = c.matcheaCalle(strDir.strCalles[0]);
    let calles2 = c.matcheaCalle(strDir.strCalles[1]);
    // Armo una lista tabu para evitar agregar 2 veces una interseccion
    // de una calle con otra que es calle y avenida a la vez
    // Ej. CIUDAD DE LA PAZ y MONROE y CIUDAD DE LA PAZ y MONROE AV.
    let matches = [];
    function matchCode(calle1, calle2) {
        return Math.min(calle1.codigo, calle2.codigo)+Math.max(calle1.codigo, calle2.codigo);
    }
    let opts = [];
    for (let i=0;i<calles1.length;i++) {

        for (let j=0; j<calles2.length; j++) {

            if (calles1[i].codigo !== calles2[j].codigo
                && matches.indexOf(matchCode(calles1[i], calles2[j])) < 0
                && c.seCruzaCon(calles1[i], calles2[j]) && c.seCruzaCon(calles2[j], calles1[i])) {

                opts.push(Direccion.construirDireccion(calles1[i], calles2[j]));
                matches.push(matchCode(calles1[i], calles2[j]));
                if (!isNaN(parseInt(maxOptions)) && opts.length >= parseInt(maxOptions))
                    break;

            }
        }

        if (!isNaN(parseInt(maxOptions)) && opts.length >= parseInt(maxOptions))
            break;
    }
    if (opts.length === 0 && calles1.length > 0 && calles2.length > 0) {
        let palabrasCalle1 = strDir.strCalles[0].split(' ');
        let palabrasCalle2 = strDir.strCalles[1].split(' ');
        if (palabrasCalle1.indexOf('AV') >= 0 || palabrasCalle1.indexOf('AVDA') >= 0 || palabrasCalle1.indexOf('AVENIDA') >= 0) {
            let strDir1 = Object.assign(Object.create(strDir), strDir);
            strDir1.quitarAvsCalle();
            let opts1;
            try {
                opts1 = normalizarCalleYCalle(strDir1, maxOptions);
            } catch (error) {
                throw(new exceptions.ErrorCruceInexistente(strDir.strCalles[0], calles1, strDir.strCalles[1], calles2));
            }
            filtrarCallesQueNoSonAv(opts1);
            if (opts1 instanceof Array)
                return opts1;
        }
        if (palabrasCalle2.indexOf('AV') >= 0 || palabrasCalle2.indexOf('AVDA') >= 0 || palabrasCalle2.indexOf('AVENIDA') >= 0) {
            let strDir2 = Object.assign(Object.create(strDir), strDir);
            strDir2.quitarAvsCalleCruce();
            let opts2;
            try {
                opts2 = normalizarCalleYCalle(strDir2, maxOptions);
            } catch (error) {
                throw(new exceptions.ErrorCruceInexistente(strDir.strCalles[0], calles1, strDir.strCalles[1], calles2));
            }
            filtrarCallesQueNoSonAv(opts2, 'getCalleCruce');
            if (opts2 instanceof Array)
                return opts2;
        }
    }
    // Esto es para sallet el caso de calles con Y en el nombre pero
    // que aun no estan escritas completas
    // Ej. ORTEGA Y GA
    if (opts.length < maxOptions) {
        let calles = c.matcheaCalle(strDir.strInput);
        let i = 0;
        while(opts.length < maxOptions && i < calles.length) {
            opts.push(calles[i]);
            i++;
        }
    }
    if (opts.length == 0 && calles1.length > 0 && calles2.length > 0) {
        throw(new exceptions.ErrorCruceInexistente(strDir.strCalles[0], calles1, strDir.strCalles[1], calles2));
    }
    return opts;
}

function setHandler(ev, handler) {
    let found = false;
    for (let i=0; i < listeners[ev].length; i++) {
        found = found || (listeners[ev][i] == handler);
    }
    if (!found) {
        listeners[ev].push(handler);
    }
}

function normalizar(str, maxOptions, autoDesambiguar){
    if (typeof(autoDesambiguar)==='undefined') {
        autoDesambiguar = true;
    }
    let strDir = new StringDireccion(str, opts.aceptarCallesSinAlturas);
    let res = [];
    switch(strDir.tipo) {
        case CALLE:
            res = c.matcheaCalle(strDir.strCalles, maxOptions);
            break;
        case CALLE_ALTURA:
            res = normalizarCalleAltura(strDir, maxOptions, autoDesambiguar);
            break;
        case CALLE_Y_CALLE:
            res = normalizarCalleYCalle(strDir, maxOptions);
            if (res.length === 0) {
                strDir.setearCalleAltura();
                res = normalizarCalleAltura(strDir, maxOptions, autoDesambiguar);
            }
            break;
        case INVALIDO:
            res = [];
            break;
    }
    if (res instanceof Array) {
        if (res.length > 0) {
            return res;
        } else {
            throw new exceptions.ErrorCalleInexistente(str);
        }
    } else {
        return res;
    }
}

function buscarCruceCalles(texto, posConector, lenConector) {
	/*
	 * Con texto = "Av. Callao y Av. Corrientes" quedaria:
	 * textoCruce = "Av. Corrientes"
	 * textoCalle = "oallaC .vA"
	 */
    textoCalle = texto.substring(0, posConector).reverse();
    textoCruce = texto.substr(posConector + lenConector);
    conector = texto.substr(posConector, lenConector);
    let calle = cruce = "";
    let rCalle = rCruce = [];

    try{
        try{
            for (let i = 1; i < opts.maxPalabras; ++i){
                cruce = textoCruce.match(re.calle[i])[0];
                if (textoCruce.search(re.calle[i]) != 0)
                    throw "Direccion no valida";
                rCruce = normalizar(cruce, 2, false);
            }
        }catch(err){
            cruce = textoCruce.match(re.calle[i-1])[0];
        }
        try{
            for (let i = 1; i < opts.maxPalabras; ++i){
                calle = textoCalle.match(re.calle[i])[0].reverse();
                if (textoCalle.search(re.calle[i]) != 0)
                    throw "Direccion no valida";
                rCalle = normalizar(calle, 2, false);
            }
        }catch(err){
            calle = textoCalle.match(re.calle[i-1])[0].reverse();
        }

        resultados = normalizar(calle + conector + cruce, 2, false);
        if(resultados.length == 1 && verificarBusquedaDireccion(resultados[0], calle + conector + cruce))
            return {
                "match": resultados[0],
                "pos": texto.search(calle),
                "len": calle.length + conector.length + cruce.length
            };
        else{
            return false;
        }
    } catch(e) {return false;}
    return false;
}

function buscarCalleAltura(texto) {
    textoDireccion = texto.reverse();
    let direccion = "";
    let rDireccion = [];
    try{
        try{
            for (let i = 1; i < opts.maxPalabras; ++i){
                direccion = textoDireccion.match(re.calleAltura[i])[0].reverse();
                if (textoDireccion.search(re.calleAltura[i]) != 0)
                    throw "Direccion no valida";
                rDireccion = normalizar(direccion, 2, false);
            }
        }catch(err){
            direccion = textoDireccion.match(re.calleAltura[i-1])[0].reverse();
            rDireccion = normalizar(direccion, 2, false);
        }
        if(verificarBusquedaDireccion(rDireccion[0], direccion)) {
            return {
                "match": rDireccion[0],
                "pos": texto.search(direccion),
                "len": direccion.length
            };
        }
    } catch(e) {return false;}
    return false;
}

function _buscarDirecciones(texto, resultadosMaximos){
    let resultados=[];
    let rePosiblesDirecciones = /((\s+y\s+)|(\s+\d+))/gi;
    while (matcheo = rePosiblesDirecciones.exec(texto)){
        if(matcheo[0].match(re.cruceCalles)){
            res = buscarCruceCalles(texto, matcheo.index, matcheo[0].length)
        }else{
            res = buscarCalleAltura(texto.substring(0, matcheo.index + matcheo[0].length));
        }
        if(res){
            if (resultados.length > 0){
                if (res.pos == resultados[resultados.length-1].pos && res.match.toString() == resultados[resultados.length-1].match.toString()){
                    if (res.len > resultados[resultados.length-1].len){
                        resultados.pop();
                        resultados.push(res);
                    }
                }else{
                    resultados.push(res);
                }
            }else{
                resultados.push(res);
            }
        }
        if (!(!resultadosMaximos || resultados.length < resultadosMaximos))
            return resultados;
    }
    return resultados.length>0?resultados:false;
}

function sinAcentos(str){
    //let rExps=[/[\xC0-\xC2]/g, /[\xC8-\xCA]/g, /[\xCC-\xCE]/g, /[\xD2-\xD4]/g, /[\xD9-\xDB]/g, /[\xD1-\xF1]/g];
    let rExps =   ['Á','É','Í','Ó','Ú','Ü'];
    let repChar = ['A','E','I','O','U','U'];
    for(let i=0; i<rExps.length; ++i){
        str=str.replace(rExps[i],repChar[i]);
    }
    return str;
}

function verificarBusquedaDireccion(posibleDireccion, matcheo){
    let pMatcheo = sinAcentos(matcheo.toUpperCase()).split(' ')
    let pCalle = posibleDireccion.toString().toUpperCase().replace(/[,.]/g,'').split(' ')
    for (let i=0;i<pMatcheo.length-1;i++){
        for (let j=0;j<pCalle.length-1;j++){
            if (pMatcheo[i]==pCalle[j] && pMatcheo[i].length>3){
                return true;
            }
        }
    }
    //ninguna palabra del texto coincide con el nombre de la calle.
    return false;
}

function compararIndices(a,b){
    return a.pos-b.pos;
}

const Normalizador = {

    /**
     * Intenta interpretar el string que recibe como parametro como una direccion y obtener como
     * resultado una direccion normalizada. En cualquier caso devuelve un Array con los resultados
     * obtenidos del intento. Dicho Array puede constar de calles (instancias de la clase usig.Calle) o
     * direcciones (instancias de la clase direccion).
     * En caso de que no se puedan encontrar direcciones o calles validas se pueden lanzar las siguientes <b>Excepciones</b>:
     * <code>ErrorCalleInexistente</code>, <code>ErrorCalleInexistenteAEsaAltura</code> y <code>ErrorCruceInexistente</code>
     * cuyos nombres son autoexplicativos.
     *
     * Todos las clases de los elementos que se devuelven implementan el metodo toString() que permite
     * mostrar los resultados. Ejemplos de uso:
     * <pre><code>
     let n = new usig.NormalizadorDirecciones();

     try {
	    n.normalizar('sarmiento', 10);
	    // devuelve un array con 4 opciones (instancias de la clase usig.Calle)
	    // correspondientes a las 4 calles cuyo nombre contiene 'sarmiento'
	} catch (error) {
	  //...
	}

     try {
	    n.normalizar('martinez 1500', 10);
	    // devuelve un array con 4 opciones (instancias de la clase direccion)
	    // correspondientes a las direcciones MARTINEZ, (CASTRO/ENRIQUE/ROSAS/VICTOR) 1500
	} catch (error) {
	    // ...
	}

     try {
	    n.normalizar('florida 550', 10);
	    // devuelve un array con una instancia de la clase direccion correspondiente
	    // a FLORIDA 550
	} catch (error) {
	    // ...
	}

     try {
	    n.normalizar('callao y corrientes', 10);
	    // devuelve un array con una instancia de la clase direccion correspondiente
	    // a CALLAO AV. y CORRIENTES AV.
	} catch (error) {
	    // ...
	}

     </code></pre>
     * @param {String} str La cadena a ser transformada en direccion
     * @param {Integer} maxOptions Maximo numero de opciones a retornar
     * @param {Boolean} (optional) autoDesambiguar Intentar desambiguar automaticamente
     * @return {Array} Las opciones halladas que se corresponden con str
     */
    normalizar: normalizar,

    /**
     * Busca la primera direccion que encuentra en el texto
     * @param {String} texto Texto donde buscar
     * @return {Object} Retorna un objeto conteniendo la direccion (match), la posicion donde fue encontrada (pos) y la longitud del matching (len)
     */
    buscarDireccion: function(texto) {
        let res = _buscarDirecciones(texto,1);
        return res?res[0]:false;
    },

    /**
     * Busca todas las direcciones que encuentra en el texto
     * @param {String} texto Texto donde buscar
     * @param {Integer} maxResultados Maxima cantidad de resultados a retornar
     * @return {Array} Retorna un array de objetos conteniendo la direccion (match), la posicion donde fue encontrada (pos) y la longitud del matching (len)
     */
    buscarDirecciones: function(texto, resultadosMaximos) {
        let res = _buscarDirecciones(texto, resultadosMaximos);
        return res ? res : false;
    },

    /**
     * Indica si ya se cargaron los datos del callejero y pueden empezar a hacerse normalizaciones.
     * @return {Boolean} Retorna True en caso de que ya se hayan cargado los datos del callejero.
     */
    listo: function() {
        return c?c.listo():false;
    },

    /**
     * Permite sobreescribir opciones del componente
     * @param {Object} options Objeto conteniendo opciones para el componente
     */
    setOptions: function(options) {
        opts = Object.assign({}, opts, options);
    },

    /**
     * Inicializa el componente previo a su primer uso.
     * @param {Object} options (optional) Objeto conteniendo overrides para las opciones por defecto.
     * @return {Object} Devuelve una referencia al componente.
     */
    init: function(options) {
        opts = Object.assign({}, defaults, options);
        if (initialized) return new Promise ((resolve, reject) => resolve(Normalizador));
        if (!callejeroPromise) {
          callejeroPromise = Callejero.init({ lazyDataLoad: opts.lazyDataLoad,
            loadFullDatabase: opts.loadFullDatabase,
            callesEnMinusculas: opts.callesEnMinusculas,
            callejero: opts.callejero
          }).then ((callejero) => {
            c = callejero;
            Normalizador.c = c;
            for (let i=1; i<=opts.maxPalabras; i++) {
              /* Atencion: Estas regular expressions estan invertidas para poder aplicarlas siempre en el mismo sentido
               * Originales:
               * re.calleAltura[i] = new RegExp("(((\\w|\\d|á|é|í|ó|ú|ü|ñ|'|`|,)+\\s+){"+i+"}\\d+)","gi");
               * re.cruceCalle[i] = new RegExp("y(\\s+(\\w|\\d|á|é|í|ó|ú|ü|ñ|'|`|,|\\.)+){"+i+"}","gi");
               */
              re.calleAltura[i] = new RegExp("(\\d+(\\s+(\\w|\\d|á|é|í|ó|ú|ü|ñ|'|`|,|\\.)+){"+i+"})","gi");
              //re.calleAltura[i] = NUMERO (ESPACIO PALABRA)*i
              re.calle[i] = new RegExp("(\\w|\\d|á|é|í|ó|ú|ü|ñ|'|`|,|\\.)+(\\s+(\\w|\\d|á|é|í|ó|ú|ü|ñ|'|`|,|\\.)+){"+(i-1)+"}","gi");
              //re.cruceCalle[i] = PALABRA (ESPACIO PALABRA)*(i-1)
            }
            String.prototype.reverse = function () {
              return this.split('').reverse().join('');
            };
            initialized = true;
            return Normalizador;
          });
        }
        return callejeroPromise
    },

    /**
     * Indica si el componente ya ha sido inicializado.
     * @return {Boolean} Retorna True si ya se ha llamado al metodo init.
     */
    inicializado: function() {
        return initialized;
    }
};
export {Direccion, Normalizador, NormalizadorAMBA};
